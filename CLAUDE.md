# @getpultdev/sdk — TypeScript SDK for Pult

Client SDK for Pult platform. Compatible browser, Node.js, Deno, Bun.
Two layers: control plane (app management) + data plane (PostgREST queries).

## Absolute Rules

1. **This is a PUBLIC repo.** Every character is visible to the world. Zero tolerance for secrets, internal URLs, credentials, API keys, or anything that leaks internal infrastructure details.
2. **No comments in code.** The code must be self-documenting. Variable names, function names, type names must be clear enough to never need a comment. If something needs a comment to be understood, the code is wrong — refactor it.
3. **No AI traces.** Never mention AI, Claude, Claude Code, Copilot, or any AI tool anywhere in the repo. No "Generated by", no "Co-Authored-By", no AI references in commits, code, docs, or config. Zero trace.
4. **Lead dev quality.** Every line of code must look like it was written by a senior engineer with 10+ years of experience. Clean, minimal, precise. No dead code, no unused imports, no TODO comments, no placeholder logic.
5. **Security first.** No secrets in code, no hardcoded URLs that leak infra, no eval(), no unsafe patterns. All user input validated. All network calls over HTTPS. All tokens handled securely.
6. **Commit and push at every action.** One file = one commit. Each created or modified file gets its own commit unless files are strictly inseparable (e.g. a module and its test for the same feature). Push after EVERY commit, not in batches. 20 small commits > 1 big commit. Maximize number of commits.
7. **PLAN.md in the main repo is the bible.** SDK design follows the architecture and conventions defined there.

## Conventional Commits — MANDATORY

Every commit message MUST follow the Conventional Commits spec:

```
<type>(<scope>): <description>
```

Types:
- `feat`: new feature or capability
- `fix`: bug fix
- `refactor`: code restructuring without behavior change
- `docs`: documentation only
- `test`: adding or fixing tests
- `chore`: build config, dependencies, CI, tooling
- `perf`: performance improvement
- `style`: formatting, whitespace, no code change

Scopes (optional): `http`, `apps`, `deployments`, `env`, `domains`, `db`, `logs`, `auth`, `git`, `types`

Examples:
- `feat(apps): add create and delete methods`
- `fix(http): handle network errors gracefully`
- `refactor(types): split response types by module`
- `chore: update tsup to v8.1`
- `docs: add database query examples to README`

## Architecture — Two Layers

The SDK has TWO distinct clients:

### 1. Control Plane Client (api.pult.rest)
Manages apps, deployments, env vars, domains, databases.
This is the Pult management API.

```typescript
const pult = createClient({ url: 'https://api.pult.rest', apiKey: '...' })
pult.apps.create({ name: 'myapp', repo: '...' })
pult.apps.deploy('app-id')
pult.env.set('app-id', { DATABASE_URL: '...' })
pult.domains.add('app-id', 'example.com')
pult.databases.create('app-id', { size: '5Gi' })
```

### 2. Data Plane Client (db-{app}.pult.rest)
PostgREST query builder for the app's managed database.
Each app has its own PostgREST instance at a dedicated subdomain.

```typescript
const db = createDbClient({ url: 'https://db-myapp.pult.rest', apiKey: '...' })
db.from('posts').select('*').eq('published', true)
```

### 3. Auth Client (auth-{app}.pult.rest)
User authentication for the app's auth service.
Each app has its own GoTrue instance at a dedicated subdomain.

```typescript
const auth = createAuthClient({ url: 'https://auth-myapp.pult.rest' })
auth.signUp({ email: '...', password: '...' })
auth.signIn({ email: '...', password: '...' })
auth.getUser()
```

### Services NOT yet built (do NOT include in SDK):
- Storage (Phase 3 — SeaweedFS)
- Realtime (Phase 3 — WebSocket)
- Redis (Phase 3 — Valkey)
- Queue (Phase 3 — Valkey)

Only add these when their backend exists. Never ship dead code.

## SDK Structure

```
src/
├── index.ts          # createClient(), createDbClient(), createAuthClient() exports
├── client.ts         # PultClient (control plane)
├── types.ts          # All interfaces matching Go models exactly
├── http.ts           # Fetch wrapper with { data, error } pattern
├── apps.ts           # pult.apps — CRUD
├── deployments.ts    # pult.deployments — deploy, list, logs
├── env.ts            # pult.env — set, list, delete
├── domains.ts        # pult.domains — add, list, verify, delete
├── databases.ts      # pult.databases — create, get, delete, query, migrations, extensions, replicas
├── logs.ts           # pult.logs — runtime log streaming
├── git.ts            # pult.git — connect, status, disconnect
├── auth.ts           # AuthClient (data plane, separate URL per app)
└── db.ts             # PostgREST query builder (data plane, separate URL)
```

## Code Conventions

- No `any` type. Use `unknown` and narrow.
- No `enum`. Use string literal unions.
- Prefer `interface` over `type` for object shapes.
- All errors returned, never thrown (Result pattern: `{ data, error }`).
- No barrel exports except from `index.ts`.
- File names: lowercase, single word (`apps.ts`, `env.ts`, `db.ts`).
- Types must match Go models exactly (same field names, same JSON keys).
- Zero runtime dependencies. Only fetch API, EventSource, native crypto.
- Target: ES2020+ (browser + Node 18+ + Deno + Bun).
